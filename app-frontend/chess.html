<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game with AI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: fadeIn 0.5s ease;
            position: relative;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .game-setup {
            text-align: center;
            margin-bottom: 20px;
        }

        .game-mode-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
        }

        .mode-btn {
            padding: 10px 20px;
            font-size: 1em;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
        }

        .info-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            color: white;
        }

        .current-player {
            font-size: 1.2em;
            font-weight: bold;
        }

        .game-status {
            font-size: 1.1em;
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 70px);
            grid-template-rows: repeat(8, 70px);
            gap: 0;
            border: 3px solid #333;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            margin: 0 auto;
            position: relative;
        }

        .square {
            width: 70px;
            height: 70px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
        }

        .square.light {
            background: #f0d9b5;
        }

        .square.dark {
            background: #b58863;
        }

        .square:hover {
            transform: scale(1.05);
            z-index: 1;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .square.selected {
            background: #7fb069 !important;
            animation: pulse 1s infinite;
            z-index: 1;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(127, 176, 105, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(127, 176, 105, 0); }
            100% { box-shadow: 0 0 0 0 rgba(127, 176, 105, 0); }
        }

        .square.possible-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(127, 176, 105, 0.8);
            border-radius: 50%;
            animation: fadeIn 0.3s ease;
        }

        .square.possible-capture::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border: 3px solid #e74c3c;
            box-sizing: border-box;
            animation: fadeIn 0.3s ease;
        }

        .piece {
            font-size: 50px;
            user-select: none;
            transition: transform 0.2s ease;
        }

        .piece:hover {
            transform: scale(1.1);
        }

        button {
            margin-top: 20px;
            padding: 12px 30px;
            font-size: 1.1em;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: block;
            margin-left: auto;
            margin-right: auto;
            font-weight: bold;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .captured-pieces {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            display: flex;
            justify-content: space-around;
        }

        .captured-section {
            text-align: center;
        }

        .captured-section h3 {
            color: #333;
            margin-bottom: 10px;
        }

        .captured-list {
            font-size: 30px;
            line-height: 1.2;
        }

        /* Promotion Modal */
        .promotion-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .promotion-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .promotion-pieces {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            justify-content: center;
        }

        .promotion-piece {
            font-size: 60px;
            cursor: pointer;
            padding: 10px;
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .promotion-piece:hover {
            background: #f0f0f0;
            transform: scale(1.2);
        }

        /* Game Over Modal */
        .game-over-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .game-over-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            color: white;
            animation: bounceIn 0.5s ease;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        @keyframes bounceIn {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.05); }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); opacity: 1; }
        }

        .game-over-content h2 {
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .game-over-content p {
            font-size: 1.5em;
            margin-bottom: 30px;
        }

        .game-over-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        .game-over-btn {
            padding: 15px 30px;
            font-size: 1.2em;
            background: white;
            color: #667eea;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .game-over-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        }

        .thinking {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 1.2em;
            font-weight: bold;
            color: #667eea;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            z-index: 100;
            display: none;
        }

        .thinking.show {
            display: block;
            animation: pulse 1s infinite;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>♔ Chess Game ♚</h1>
        
        <div class="game-setup">
            <div class="game-mode-buttons">
                <button class="mode-btn active" onclick="setGameMode('pvp')">Player vs Player</button>
                <button class="mode-btn" onclick="setGameMode('ai-white')">Play as White vs AI</button>
                <button class="mode-btn" onclick="setGameMode('ai-black')">Play as Black vs AI</button>
            </div>
        </div>

        <div class="info-panel">
            <div class="current-player">Current Turn: <span id="currentPlayer">White</span></div>
            <div class="game-status" id="gameStatus">Game in progress</div>
        </div>
        
        <div class="chess-board" id="board"></div>
        <div class="thinking" id="thinking">AI is thinking...</div>
        
        <button onclick="resetGame()">New Game</button>
        
        <div class="captured-pieces">
            <div class="captured-section">
                <h3>White Captured</h3>
                <div class="captured-list" id="whiteCaptured"></div>
            </div>
            <div class="captured-section">
                <h3>Black Captured</h3>
                <div class="captured-list" id="blackCaptured"></div>
            </div>
        </div>
    </div>

    <!-- Promotion Modal -->
    <div class="promotion-modal" id="promotionModal">
        <div class="promotion-content">
            <h2>Choose Promotion Piece</h2>
            <div class="promotion-pieces" id="promotionPieces"> </div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div class="game-over-modal" id="gameOverModal">
        <div class="game-over-content">
            <h2 id="winnerText">Game Over!</h2>
            <p id="winnerDetails"></p>
            <div class="game-over-buttons">
                <button class="game-over-btn" onclick="resetGame(); closeGameOver();">New Game</button>
                <button class="game-over-btn" onclick="closeGameOver()">Review Board</button>
            </div>
        </div>
    </div>

    <script>
        const pieces = {
            'wK': '♔', 'wQ': '♕', 'wR': '♖', 'wB': '♗', 'wN': '♘', 'wP': '♙',
            'bK': '♚', 'bQ': '♛', 'bR': '♜', 'bB': '♝', 'bN': '♞', 'bP': '♟'
        };
        const promotionOptions = {
            'wQ': '♕', 'wR': '♖', 'wB': '♗', 'wN': '♘',
            'bQ': '♛', 'bR': '♜', 'bB': '♝', 'bN': '♞'
        };

        let board = [];
        let selectedSquare = null;
        let currentPlayer = 'white';
        let capturedPieces = { white: [], black: [] };
        let moveHistory = [];
        let gameMode = 'pvp'; // 'pvp', 'ai-white', 'ai-black'
        let gameOver = false;
        let enPassantTarget = null;
        let castlingRights = {
            white: { kingSide: true, queenSide: true },
            black: { kingSide: true, queenSide: true }
        };
        let promotionPending = null;

        function initBoard() {
            board = [
                ['bR', 'bN', 'bB', 'bQ', 'bK', 'bB', 'bN', 'bR'],
                ['bP', 'bP', 'bP', 'bP', 'bP', 'bP', 'bP', 'bP'],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                ['wP', 'wP', 'wP', 'wP', 'wP', 'wP', 'wP', 'wP'],
                ['wR', 'wN', 'wB', 'wQ', 'wK', 'wB', 'wN', 'wR']
            ];
            castlingRights = {
                white: { kingSide: true, queenSide: true },
                black: { kingSide: true, queenSide: true }
            };
            enPassantTarget = null;
            moveHistory = [];
            gameOver = false;
        }

        function setGameMode(mode) {
            gameMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            resetGame();
            
            // If AI plays white, make AI move
            if (mode === 'ai-black' && currentPlayer === 'white') {
                setTimeout(makeAIMove, 500);
            }
        }

        function renderBoard() {
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const displayRow = (gameMode === 'pvp' && currentPlayer === 'black') || gameMode === 'ai-black' ? 7 - row : row;
                    const displayCol = (gameMode === 'pvp' && currentPlayer === 'black') || gameMode === 'ai-black' ? 7 - col : col;

                    const square = document.createElement('div');
                    square.className = 'square ' + ((row + col) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.row = displayRow;
                    square.dataset.col = displayCol;
                    
                    if (board[displayRow][displayCol]) {
                        const piece = document.createElement('span');
                        piece.className = 'piece';
                        piece.textContent = pieces[board[displayRow][displayCol]];
                        square.appendChild(piece);
                    }
                    
                    square.addEventListener('click', handleSquareClick);
                    boardElement.appendChild(square);
                }
            }
        }

        function handleSquareClick(e) {
            if (gameOver) return;
            
            // Don't allow moves during AI turn
            if ((gameMode === 'ai-white' && currentPlayer === 'black') ||
                (gameMode === 'ai-black' && currentPlayer === 'white')) {
                return;
            }
            
            const square = e.currentTarget;
            const row = parseInt(square.dataset.row);
            const col = parseInt(square.dataset.col);
            
            if (selectedSquare) {
                const fromRow = selectedSquare.row;
                const fromCol = selectedSquare.col;
                
                if (isValidMove(fromRow, fromCol, row, col)) {
                    makeMove(fromRow, fromCol, row, col);
                    clearSelection();
                    
                    // Check for pawn promotion
                    if (promotionPending) {
                        showPromotionModal();
                        return;
                    }
                    
                    handleSwitchPlayer()
                } else {
                    clearSelection();
                    if (board[row][col] && isPieceOwnedByCurrentPlayer(row, col)) {
                        selectSquare(row, col);
                    }
                }
            } else {
                if (board[row][col] && isPieceOwnedByCurrentPlayer(row, col)) {
                    selectSquare(row, col);
                }
            }
        }

        function handleSwitchPlayer() {
            checkGameStatus();
            switchPlayer();
            
            // Make AI move if needed
            if (!gameOver && gameMode !== 'pvp') {
                if ((gameMode === 'ai-white' && currentPlayer === 'black') ||
                    (gameMode === 'ai-black' && currentPlayer === 'white')) {
                    setTimeout(makeAIMove, 500);
                    console.log('ai makes move here')
                }
            }
        }

        function selectSquare(row, col) {
            selectedSquare = { row, col };
            renderBoard();
            const squares = document.querySelectorAll('.square');
            squares.forEach(sq => {
                if (parseInt(sq.dataset.row) === row && parseInt(sq.dataset.col) === col) {
                    sq.classList.add('selected');
                }
            });
            showPossibleMoves(row, col);
        }

        function clearSelection() {
            selectedSquare = null;
            renderBoard();
        }

        function showPossibleMoves(row, col) {
            const squares = document.querySelectorAll('.square');
            squares.forEach(sq => {
                const targetRow = parseInt(sq.dataset.row);
                const targetCol = parseInt(sq.dataset.col);
                if (isValidMove(row, col, targetRow, targetCol)) {
                    if (board[targetRow][targetCol] || 
                        (board[row][col][1] === 'P' && isEnPassantCapture(row, col, targetRow, targetCol))) {
                        sq.classList.add('possible-capture');
                    } else {
                        sq.classList.add('possible-move');
                    }
                }
            });
        }

        function possibleMovesExist(row, col) {
            for (let targetRow = 0; targetRow < 8; targetRow++) {
                for (let targetCol = 0; targetCol < 8; targetCol++) {
                    if (isValidMove(row, col, targetRow, targetCol)) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        function anyPossibleMovesExist(color) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] && board[row][col][0] === color && possibleMovesExist(row, col)) {
                        return true
                    }
                }
            }

            return false
        }

        function isPieceOwnedByCurrentPlayer(row, col) {
            const piece = board[row][col];
            if (!piece) return false;
            return (currentPlayer === 'white' && piece[0] === 'w') ||
                   (currentPlayer === 'black' && piece[0] === 'b');
        }

        function isValidMove(fromRow, fromCol, toRow, toCol, testMode = false) {
            const piece = board[fromRow][fromCol];
            if (!piece) return false;
            
            const targetPiece = board[toRow][toCol];
            if (targetPiece && targetPiece[0] === piece[0]) return false;
            
            const pieceType = piece[1];
            let validBasicMove = false;
            
            switch (pieceType) {
                case 'P':
                    validBasicMove = isValidPawnMove(fromRow, fromCol, toRow, toCol, piece[0]);
                    break;
                case 'R':
                    validBasicMove = isValidRookMove(fromRow, fromCol, toRow, toCol);
                    break;
                case 'N':
                    validBasicMove = isValidKnightMove(fromRow, fromCol, toRow, toCol);
                    break;
                case 'B':
                    validBasicMove = isValidBishopMove(fromRow, fromCol, toRow, toCol);
                    break;
                case 'Q':
                    validBasicMove = isValidQueenMove(fromRow, fromCol, toRow, toCol);
                    break;
                case 'K':
                    validBasicMove = isValidKingMove(fromRow, fromCol, toRow, toCol, piece[0]);
                    break;
            }
            
            if (!validBasicMove) return false;
            
            // Check if move would leave king in check
            if (!testMode && wouldBeInCheck(fromRow, fromCol, toRow, toCol, piece[0])) {
                return false;
            }
            
            return true;
        }

        function isValidPawnMove(fromRow, fromCol, toRow, toCol, color) {
            const direction = color === 'w' ? -1 : 1;
            const startRow = color === 'w' ? 6 : 1;
            const rowDiff = toRow - fromRow;
            const colDiff = Math.abs(toCol - fromCol);
            
            // Regular forward move
            if (colDiff === 0) {
                if (rowDiff === direction && !board[toRow][toCol]) {
                    return true;
                }
                // Initial two-square move
                if (fromRow === startRow && rowDiff === 2 * direction && 
                    !board[toRow][toCol] && !board[fromRow + direction][fromCol]) {
                    return true;
                }
            } 
            // Diagonal capture
            else if (colDiff === 1) {
                if (rowDiff === direction) {
                    // Regular capture
                    if (board[toRow][toCol] && board[toRow][toCol][0] !== color) {
                        return true;
                    }
                    // En passant capture
                    if (isEnPassantCapture(fromRow, fromCol, toRow, toCol)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function isEnPassantCapture(fromRow, fromCol, toRow, toCol) {
            if (!enPassantTarget) return false;
            return toRow === enPassantTarget.row && toCol === enPassantTarget.col &&
                   board[fromRow][fromCol][1] === 'P';
        }

        function isValidRookMove(fromRow, fromCol, toRow, toCol) {
            if (fromRow !== toRow && fromCol !== toCol) return false;
            
            const rowStep = fromRow === toRow ? 0 : (toRow > fromRow ? 1 : -1);
            const colStep = fromCol === toCol ? 0 : (toCol > fromCol ? 1 : -1);
            
            let currentRow = fromRow + rowStep;
            let currentCol = fromCol + colStep;
            
            while (currentRow !== toRow || currentCol !== toCol) {
                if (board[currentRow][currentCol]) return false;
                currentRow += rowStep;
                currentCol += colStep;
            }
            
            return true;
        }

        function isValidKnightMove(fromRow, fromCol, toRow, toCol) {
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);
            return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
        }

        function isValidBishopMove(fromRow, fromCol, toRow, toCol) {
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);
            
            if (rowDiff !== colDiff) return false;
            
            const rowStep = toRow > fromRow ? 1 : -1;
            const colStep = toCol > fromCol ? 1 : -1;
            
            let currentRow = fromRow + rowStep;
            let currentCol = fromCol + colStep;
            
            while (currentRow !== toRow || currentCol !== toCol) {
                if (board[currentRow][currentCol]) return false;
                currentRow += rowStep;
                currentCol += colStep;
            }
            
            return true;
        }

        function isValidQueenMove(fromRow, fromCol, toRow, toCol) {
            return isValidRookMove(fromRow, fromCol, toRow, toCol) || 
                   isValidBishopMove(fromRow, fromCol, toRow, toCol);
        }

        function isValidKingMove(fromRow, fromCol, toRow, toCol, color) {
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);
            
            // Regular king move
            if (rowDiff <= 1 && colDiff <= 1) {
                return true;
            }
            
            // Castling
            if (rowDiff === 0 && colDiff === 2) {
                return canCastle(fromRow, fromCol, toRow, toCol, color);
            }
            
            return false;
        }

        function canCastle(fromRow, fromCol, toRow, toCol, color) {
            const row = color === 'w' ? 7 : 0;
            if (fromRow !== row || fromCol !== 4) return false;
            
            // Check if king is in check
            if (isInCheck(color)) return false;
            
            // King side castling
            if (toCol === 6) {
                if (!castlingRights[color === 'w' ? 'white' : 'black'].kingSide) return false;
                if (board[row][5] || board[row][6]) return false;
                if (board[row][7] !== (color + 'R')) return false;
                
                // Check if king passes through check
                if (wouldBeInCheck(fromRow, fromCol, row, 5, color) ||
                    wouldBeInCheck(fromRow, fromCol, row, 6, color)) {
                    return false;
                }
                return true;
            }
            
            // Queen side castling
            if (toCol === 2) {
                if (!castlingRights[color === 'w' ? 'white' : 'black'].queenSide) return false;
                if (board[row][1] || board[row][2] || board[row][3]) return false;
                if (board[row][0] !== (color + 'R')) return false;
                
                // Check if king passes through check
                if (wouldBeInCheck(fromRow, fromCol, row, 3, color) ||
                    wouldBeInCheck(fromRow, fromCol, row, 2, color)) {
                    return false;
                }
                return true;
            }
            
            return false;
        }

        function isInCheck(color) {
            // Find king position
            let kingRow = -1, kingCol = -1;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === color + 'K') {
                        kingRow = row;
                        kingCol = col;
                        break;
                    }
                }
            }
            
            // Check if any opponent piece can capture the king
            const opponentColor = color === 'w' ? 'b' : 'w';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] && board[row][col][0] === opponentColor) {
                        if (isValidMove(row, col, kingRow, kingCol, true)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function wouldBeInCheck(fromRow, fromCol, toRow, toCol, color) {
            // Make temporary move
            const originalPiece = board[toRow][toCol];
            const movingPiece = board[fromRow][fromCol];
            board[toRow][toCol] = movingPiece;
            board[fromRow][fromCol] = null;
            
            const inCheck = isInCheck(color);
            
            // Restore board
            board[fromRow][fromCol] = movingPiece;
            board[toRow][toCol] = originalPiece;
            
            return inCheck;
        }

        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol];
            
            // Handle en passant capture
            if (piece[1] === 'P' && isEnPassantCapture(fromRow, fromCol, toRow, toCol)) {
                const captureRow = fromRow;
                const capturedPawn = board[captureRow][toCol];
                board[captureRow][toCol] = null;
                const color = capturedPawn[0] === 'w' ? 'black' : 'white';
                capturedPieces[color].push(capturedPawn);
                updateCapturedDisplay();
            }
            
            // Handle regular capture
            if (capturedPiece) {
                const color = capturedPiece[0] === 'w' ? 'black' : 'white';
                capturedPieces[color].push(capturedPiece);
                updateCapturedDisplay();
            }
            
            // Update en passant target
            enPassantTarget = null;
            if (piece[1] === 'P' && Math.abs(toRow - fromRow) === 2) {
                enPassantTarget = {row: toRow === 3 ? 2 : 5, col: toCol};
            }

            // Handle pawn promotion
            if (piece[1] === 'P' && (toRow === 0 || toRow === 7)) {
                promotionPending = {row: toRow, col: toCol};
            }

            // Handle castled rook
            if (piece[1] === 'K' && Math.abs(fromCol - toCol) > 1) {
                color = piece[0];
                direction = fromCol < toCol ? 1 : -1;
                board[color == 'w' ? 7 : 0][direction === 1 ? 7 : 0] = null;
                board[fromRow][toCol - direction] = color + 'R';

                castlingRights.white.kingSide = castlingRights.white.kingSide && !(color === 'w' && direction > 0)
                castlingRights.white.queenSide = castlingRights.white.queenSide && !(color === 'w' && direction < 0)
                castlingRights.black.kingSide = castlingRights.black.kingSide && !(color === 'b' && direction > 0)
                castlingRights.black.queenSide = castlingRights.black.queenSide && !(color === 'b' && direction < 0)
            };

            // Check castling rights
            if (piece[1] === 'K') {
                if (piece[0] === 'w') {
                    castlingRights.white.kingSide = false;
                    castlingRights.white.queenSide = false;
                } else {
                    castlingRights.black.kingSide = false;
                    castlingRights.black.queenSide = false;
                }
            }
            if (piece === 'wR') {
                if (fromCol === 0 && fromRow === 7) castlingRights.white.queenSide = false;
                if (fromCol === 7 && fromRow === 7) castlingRights.white.kingSide = false;
            }
            if (piece === 'bR') {
                if (fromCol === 0 && fromRow === 0) castlingRights.black.queenSide = false;
                if (fromCol === 7 && fromRow === 0) castlingRights.black.kingSide = false;
            }
            
            board[toRow][toCol] = board[fromRow][fromCol];
            board[fromRow][fromCol] = null;
            renderBoard();
            checkGameStatus();
        }

        function updateCapturedDisplay() {
            document.getElementById('whiteCaptured').textContent = 
                capturedPieces.white.map(p => pieces[p]).join(' ');
            document.getElementById('blackCaptured').textContent = 
                capturedPieces.black.map(p => pieces[p]).join(' ');
        }

        function switchPlayer() {
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            document.getElementById('currentPlayer').textContent = 
                currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1);
            renderBoard();
        }

        function showPromotionModal() {
            const modal = document.getElementById('promotionModal');
            const container = document.getElementById('promotionPieces');
            if (!modal || !container) return;

            container.innerHTML = '';
            modal.style.display = 'flex';
            const nameMap = { Q: 'Queen', R: 'Rook', B: 'Bishop', N: 'Knight' };

            Object.entries(promotionOptions)
            .filter(piece => piece[0][0] === currentPlayer[0])
            .forEach(([piece, symbol]) => {
                const pieceChar = piece[1];
                const button = document.createElement('button');
                button.className = 'promotion-button';
                button.innerHTML = `${symbol} <span>${nameMap[pieceChar]}</span>`;
                button.onclick = () => {
                    modal.style.display = 'none';
                    handlePromotion(piece)
                };
                container.appendChild(button);
            });
        }

        function handlePromotion(piece) {
            const toRow = promotionPending['row'];
            const toCol = promotionPending['col'];
            board[toRow][toCol] = piece;
            promotionPending = null;
            renderBoard();
            handleSwitchPlayer();
        }

        function checkGameStatus() {
            colorToCheck = currentPlayer === 'white' ? 'b' : 'w';
            gameOver = !anyPossibleMovesExist(colorToCheck);
            if (gameOver && isInCheck(colorToCheck)) {
                showGameOverModal()
            }
        }

        function showGameOverModal() {
            const modal = document.getElementById('gameOverModal')
            modal.style.display = 'flex';
        }

        function closeGameOver() {
            const modal = document.getElementById('gameOverModal')
            modal.style.display = 'none';
        }

        function resetGame() {
            initBoard();
            currentPlayer = 'white';
            capturedPieces = { white: [], black: [] };
            selectedSquare = null;
            document.getElementById('currentPlayer').textContent = 'White';
            document.getElementById('gameStatus').textContent = 'Game in progress';
            document.getElementById('whiteCaptured').textContent = '';
            document.getElementById('blackCaptured').textContent = '';
            let castlingRights = {
                white: { kingSide: true, queenSide: true },
                black: { kingSide: true, queenSide: true }
            };
            let promotionPending = null;
            renderBoard();
        }
        
        // Initialize the game
        initBoard();
        renderBoard();
    </script>
</body>
</html>